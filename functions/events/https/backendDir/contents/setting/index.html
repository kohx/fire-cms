{|@ wrapper |}
{|> header |}

<div class="col0 grid1 gap1">
    <ul>
        {|* targets: targetName: targetValue |}
        {|# targetValue |}
        <li>
            <h2>{| targetName |}</h2>
            <ul class="grid1 gap1 pad1 {| targetName |}">
                {|* targetValue: itemName: itemValue |}
                <li class="grid3 gap1">
                    <label class="col1 cen mid">{| itemName |}</label>
                    <input class="setting_item col2 {| itemName |} " type="text" data-default="{| itemValue |}"
                        data-target="{| targetName |}" data-item="{| itemName |}" value="{| itemValue |}">
                </li>
                {|/*|}
            </ul>
        </li>
        {|/#|}
        {|/*|}
    </ul>

    <button class="col1" type="button" id="updateBtn" data-url="/{| backendFirstPath |}/setting-update">update</button>

</div>
{|> footer |}

<script type="module">

    import { Base } from '/{| backendFirstPath |}/base.js';
    const base = Base.init()

    const updateBtnElement = document.querySelector('#updateBtn')
    const targetItems = document.querySelectorAll('.setting_item')
    const notice = document.querySelector('.notice')

    Object.keys(targetItems).forEach(key => {
        const element = targetItems[key]
        element.addEventListener('keyup', event => {

            /* if change valeu add _modified class */
            if (event.target.dataset.default != event.target.value) {
                event.target.classList.remove('__warning', '__success')
                event.target.classList.add('_modified')
            } else {
                event.target.classList.remove('_modified')
            }

            /* if enter key up then next one focused */
            if(event.keyCode === 13){
                if((targetItems.length - 1) <= key){
                    targetItems[0].focus()
                    targetItems[0].setSelectionRange(-1, -1)
                } else {
                    targetItems[Number(key) + 1].focus()
                    targetItems[Number(key) + 1].setSelectionRange(-1, -1)
                }
            }

            // クライアント側 validation
            const result = v8n()
                .string()
                .test("My string!"); //true
            // console.log(result)
        })
    })

    let processing = false
    updateBtnElement.addEventListener('click', event => {
        if(processing){
            return 
        }
        processing = true
        event.target.disabled = true;
        
        const url = event.target.dataset.url
        const unique = event.target.dataset.unique
        const updateItems = document.querySelectorAll('._modified')

        if (updateItems.length === 0) {
            base.setNotice('warning', ['Nothing has changed.'])
            processing = false
            event.target.disabled = false;
            return
        }

        const body = {}
        Object.keys(updateItems).forEach(key => {
            const element = updateItems[key]
            if (!body.hasOwnProperty(element.dataset.target)) {
                body[element.dataset.target] = {}
            }
            body[element.dataset.target][element.dataset.item] = element.value
        })

        base.fetchPost(url, body)
            .then(result => {

                // get type
                const type = result.status ? 'success' : 'warning'

                let messages = []
                result.messages.forEach(message => {

                    // rebuild message
                    messages.push(message.content)

                    // get selector from key
                    let key = message.key
                    const selector = key =! null ? `.${key.replace('.', ' .')}` : false
                    
                    // has selector
                    if(selector){
                        const element = document.querySelector(selector)

                        // set type class
                        element.classList.remove('__warning', '__success')
                        element.classList.add(`__${type}`)

                        // status is success
                        if(result.status){
                            // then remove _modified class
                            element.classList.remove('_modified')

                            // and remove _modified class
                            let value = Object.assign({}, result.values)
                            message.key.split('.').forEach(path => {
                               value = value[path.trim()]
                            })

                            value = Array.isArray(value) ? value.join(', ') : value
                            element.value = value
                            element.dataset.default = value
                        }
                    }
                })

                base.setNotice(type, messages)
                processing = false
                event.target.disabled = false;
            })
            .catch(err => {
                base.setNotice('error', [err.message])
                console.log(err)

                processing = false
                event.target.disabled = false;
            })
    })
</script>